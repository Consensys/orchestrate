---

stages:
  # - test
  # - integration
  # - e2e
  # - build
  # - release
  - doc

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  GOPATH: ${CI_PROJECT_DIR}/.gocache
  ARTIFACT_DOWNLOAD_ATTEMPTS: 5
  RESTORE_CACHE_ATTEMPTS: 5

services:
  - docker:19.03-dind

.rules: &rules
  rules:
    - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "master" || $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH =~ /^maintenance/'
      when: on_success
      allow_failure: false
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_COMMIT_BRANCH != "master"
      when: manual

.go-cache:
  before_script:
    - mkdir -p ${GOPATH}
  cache:
    paths:
      - ${GOPATH}/pkg/mod/

.go-setup: &go-setup
  image: golang:1.14
  stage: test
  extends: .go-cache
  before_script:
    # Set GOPATH
    - mkdir -p ${GOPATH}
    - export PATH="${PATH}:${GOPATH}/bin:${GOROOT}/bin"

.docker-setup: &docker-setup
  image: docker:19.03
  stage: build
  before_script:
    - export DOCKER_API_VERSION=1.39
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
  after_script:
    - docker logout $CI_REGISTRY

.docker-compose-e2e: &docker-compose-e2e
  stage: e2e
  before_script:
    - apk update
    - apk add make bash jq curl build-base
    - apk add --no-cache py3-pip python3
    - apk add --no-cache --virtual build-dependencies python3-dev libffi-dev openssl-dev gcc libc-dev
    - pip3 install docker-compose==1.26.0
  after_script:
    - make down
  cache:
    key: "$CI_COMMIT_REF_SLUG"
    paths:
      - build/bin/
  artifacts:
    when: always
    paths:
      - build/report/

.build-orchestrate: &build-orchestrate
  # Build orchestrate image following http://label-schema.org/rc1/ label convention convention
  - DOCKER_BUILDKIT=1 docker build
    --label org.label-schema.schema-version="1.0.0-rc1"
    --label org.label-schema.build-date=`date -u +"%Y-%m-%dT%H:%M:%SZ"`
    --label org.label-schema.name="${CI_PROJECT_NAME}"
    --label org.label-schema.version="branch"
    --label org.label-schema.url="https://docs.orchestrate.pegasys.tech"
    --label org.label-schema.vcs-url="${CI_PROJECT_URL}"
    --label org.label-schema.vcs-ref="${CI_COMMIT_SHA:0:8}"
    --label org.label-schema.vendor="PegaSys"
    -t ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} .
  # Push images
  - docker push ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}

.build-e2e: &build-e2e
  # Build e2e image
  - DOCKER_BUILDKIT=1 docker build
    --label org.label-schema.schema-version="1.0.0-rc1"
    --label org.label-schema.build-date=`date -u +"%Y-%m-%dT%H:%M:%SZ"`
    --label org.label-schema.name="${CI_PROJECT_NAME}/e2e"
    --label org.label-schema.version="branch"
    --label org.label-schema.url="https://docs.orchestrate.pegasys.tech"
    --label org.label-schema.vcs-url="${CI_PROJECT_URL}"
    --label org.label-schema.vcs-ref="${CI_COMMIT_SHA:0:8}"
    --label org.label-schema.vendor="PegaSys"
    -f ./tests/Dockerfile
    -t ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA} .
  # Push images
  - docker push ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA}

.build-pages: &build-pages
  # Release static swagger doc for latest version on Gitlab pages
  image: node:12.16.2-stretch-slim
  before_script:
    #    - |
    #      if [ -z "$CI_COMMIT_TAG" ]; then
    #        exit 1
    #      elif [[ $CI_COMMIT_TAG == *"-rc"* ]]; then
    #        DOC_VERSION="latest"
    #      else
    #        DOC_VERSION="stable"
    #      fi
    - DOC_VERSION="latest"
    - npm install swagger-combine@1.1.2
    - npm install redoc-cli@0.9.10
    - export PATH="$PATH:$(pwd)/node_modules/.bin"
    - mkdir -p "public/${DOC_VERSION}"
    - rm -rf "public/${DOC_VERSION}/*";
  script:
    # replace version placeholder in combine template before running it
    - sed -e "s~{{API_VERSION}}~${DOC_VERSION} - ${CI_COMMIT_SHORT_SHA}~" swagger-combine.yml.template > swagger-combine.yml
    # combine specs
    - swagger-combine swagger-combine.yml -o combined-schema.json
    # generate doc using ReDoc
    - redoc-cli bundle combined-schema.json
    # copy html file to the right folder and name it index for online access with dir path only
    # keep this in prevision of having multiple versions and also now because of compatibility
    # with previous urls already indexed by search engines
    - mv redoc-static.html public/${DOC_VERSION}/index.html
    # create a redirect from home to latest for people landing on root
    - sed -e "s~{{LATEST_VERSION_URL}}~${CI_PAGES_URL}/latest~" public/index.html.template > public/index.html

.release-notes: &release-notes
  # Create a PR with release note changes in doc repos
  image: debian:stable-slim
  before_script:
    - apt-get update -y && apt-get install -yqqf openssh-client git unzip sshpass rsync --fix-missing
    - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git -y )'
    - eval $(ssh-agent -s)
    - echo "${DOC_GITHUB_SSH_PRIV}" | tr -d '\r' | ssh-add - > /dev/null

    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh

    - ssh-keyscan github.com >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

    - git config --global user.email "ops-quorum@consensys.net"
    - git config --global user.name "Orchestrate CI"
  script:
    - git clone git@github.com:ConsenSys/doc.orchestrate.git
    - ls -la

# test:
#   <<: *go-setup
#   <<: *rules
#   coverage: /^total:.*\s(\d+.\d+)%/
#   services:
#     - postgres:10.12-alpine
#   variables:
#     POSTGRES_PASSWORD: "postgres"
#     DB_HOST: "postgres"
#   script:
#     - make run-coverage
#
# integration:
#   <<: *go-setup
#   <<: *rules
#   services:
#     - docker:19.03-dind
#   variables:
#     DOCKER_HOST: tcp://docker:2375
#     DOCKER_TLS_CERTDIR: ""
#     DB_HOST: "docker"
#     KAFKA_HOST: "docker"
#     KAFKA_URL: "docker:9092"
#   script:
#     - make run-integration
#
# lint:
#   <<: *go-setup
#   <<: *rules
#   script:
#     - make lint-tools
#     - make lint-ci
#
# race:
#   <<: *go-setup
#   <<: *rules
#   script:
#     - make race
#
# gobuild:
#   <<: *go-setup
#   <<: *rules
#   script:
#     - make gobuild
#     - make gobuild-e2e
#   cache:
#     key: "$CI_COMMIT_REF_SLUG"
#     paths:
#       - build/bin/
#
# test-e2e:
#   <<: *docker-compose-e2e
#   <<: *rules
#   script:
#     - mv -f .env.ci .env
#     - make up-ci
#     - make e2e-ci
#     - exit $(docker inspect orchestrate_e2e_1 --format='{{.State.ExitCode}}')
#
# test-multitenancy-e2e:
#   <<: *docker-compose-e2e
#   <<: *rules
#   script:
#     - mv -f .env.multitenancy .env
#     - make up-ci
#     - make e2e-ci
#     - exit $(docker inspect orchestrate_e2e_1 --format='{{.State.ExitCode}}')
#
# test-stress:
#   <<: *docker-compose-e2e
#   only:
#     refs:
#       - master
#   script:
#     - mv -f .env.ci .env
#     - make up-ci
#     - make stress-ci
#     - exit $(docker inspect orchestrate_stress_1 --format='{{.State.ExitCode}}')
#
# #Build orchestrate
# build-orchestrate-on-branch:
#   <<: *docker-setup
#   script:
#     - *build-orchestrate
#   only:
#     - /^dev\/[a-zA-Z0-9\/\-.]*$/
#     - /^feature\/[a-zA-Z0-9\/\-.]*$/
#     - /^fix\/[a-zA-Z0-9\/\-.]*$/
#     - /^maintenance\/[a-zA-Z0-9\/\-.]*$/
#     - /^release\/[a-zA-Z0-9\/\-.]*$/
#
# build-orchestrate-on-master:
#   <<: *docker-setup
#   script:
#     - *build-orchestrate
#     - docker tag ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} ${CI_REGISTRY_IMAGE}:latest
#     - docker push ${CI_REGISTRY_IMAGE}:latest
#   only:
#     - master
#
# build-orchestrate-on-tag:
#   <<: *docker-setup
#   script:
#     # `tag` doesnt build a new image, just applies tag existing commit on master
#     - docker pull ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}
#     - docker tag ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} ${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}
#     - docker push ${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}
#   only:
#     refs:
#       - tags
#
# release-orchestrate:
#   image: docker:19.03
#   stage: release
#   before_script:
#     - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
#     - docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_KEY} ${DOCKER_REGISTRY}
#     - docker login -u ${DOCKER_REGISTRY_USER_2} -p ${DOCKER_REGISTRY_KEY_2} ${DOCKER_REGISTRY_2}
#   script:
#     - docker pull ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}
#     - docker tag ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} ${DOCKER_REGISTRY}/orchestrate:${CI_COMMIT_TAG}
#     - docker push ${DOCKER_REGISTRY}/orchestrate:${CI_COMMIT_TAG}
#     - docker tag ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} ${DOCKER_REGISTRY_2}${DOCKER_REPOSITORY_2}/orchestrate:${CI_COMMIT_TAG}
#     - docker push ${DOCKER_REGISTRY_2}${DOCKER_REPOSITORY_2}/orchestrate:${CI_COMMIT_TAG}
#   after_script:
#     - docker logout $CI_REGISTRY
#     - docker logout ${DOCKER_REGISTRY}
#     - docker logout ${DOCKER_REGISTRY_2}
#   only:
#     refs:
#       - tags
#   when: manual
#
# #Build e2e
# build-e2e-on-branch:
#   <<: *docker-setup
#   script:
#     - *build-e2e
#   only:
#     - /^dev\/[a-zA-Z0-9\/\-.]*$/
#     - /^feature\/[a-zA-Z0-9\/\-.]*$/
#     - /^fix\/[a-zA-Z0-9\/\-.]*$/
#     - /^maintenance\/[a-zA-Z0-9\/\-.]*$/
#     - /^release\/[a-zA-Z0-9\/\-.]*$/
#
# build-e2e-on-master:
#   <<: *docker-setup
#   script:
#     - *build-e2e
#     - docker tag ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA} ${CI_REGISTRY_IMAGE}/e2e:latest
#     - docker push ${CI_REGISTRY_IMAGE}/e2e:latest
#   only:
#     refs:
#       - master
#
# build-e2e-on-tag:
#   <<: *docker-setup
#   script:
#     # `tag` doesnt build a new image, just applies tag existing commit on master
#     - docker pull ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA}
#     - docker tag ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA} ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_TAG}
#     - docker push ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_TAG}
#   only:
#     refs:
#       - tags
#
# release-e2e:
#   image: docker:19.03
#   stage: release
#   before_script:
#     - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
#     - docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_KEY} ${DOCKER_REGISTRY}
#     - docker login -u ${DOCKER_REGISTRY_USER_2} -p ${DOCKER_REGISTRY_KEY_2} ${DOCKER_REGISTRY_2}
#   script:
#     - docker pull ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA}
#     - docker tag ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA} ${DOCKER_REGISTRY}/e2e:${CI_COMMIT_TAG}
#     - docker push ${DOCKER_REGISTRY}/e2e:${CI_COMMIT_TAG}
#     - docker tag ${CI_REGISTRY_IMAGE}/e2e:${CI_COMMIT_SHORT_SHA} ${DOCKER_REGISTRY_2}${DOCKER_REPOSITORY_2}/orchestrate-e2e:${CI_COMMIT_TAG}
#     - docker push ${DOCKER_REGISTRY_2}${DOCKER_REPOSITORY_2}/orchestrate-e2e:${CI_COMMIT_TAG}
#   after_script:
#     - docker logout $CI_REGISTRY
#     - docker logout ${DOCKER_REGISTRY}
#     - docker logout ${DOCKER_REGISTRY_2}
#   only:
#     refs:
#       - tags
#   when: manual
#
# # IMPORTANT: this job name can't be changed!
# # It has to be "pages" for GitlabCI to recognize it.
# # see https://docs.gitlab.com/ee/user/project/pages/introduction.html#gitlab-pages-requirements
# pages:
#   <<: *build-pages
#   # must be on the last stage to make sure the doc is updated only if everything passed
#   stage: doc
#   #  cache:
#   #    paths:
#   #      - public
#   artifacts:
#     when: always
#     paths:
#       - public/${DOC_VERSION}
#     # no need to keep the artifact more than required to check for an issue
#     expire_in: 1 day
#   only:
#     refs:
#       - tags
release-notes:
  <<: *release-notes
  # must be on the last stage to make sure the doc is updated only if everything passed
  stage: doc
  # only:
  #   refs:
  #     - tags
